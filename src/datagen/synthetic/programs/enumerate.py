"""Column enumeration for compositional programs (no arbitrary selection).

Key rule: If multiple eligible columns exist, enumerate ALL.
No selection by "first" or position allowed."""

from typing import List, Dict, Any
from src.datagen.synthetic.programs.spec import ProgramSpec, OpInstance
from src.datagen.synthetic.programs.operators import (
    get_eligible_numeric_cols,
    get_eligible_binary_categorical_cols,
    get_operator,
)


def enumerate_bindings(
    chains: List[List[OpInstance]], profile: Dict[str, Any]
) -> List[ProgramSpec]:
    """
    Enumerate all valid column bindings for each operator chain.

    This is where we avoid "first column" selection - we generate
    a separate ProgramSpec for each eligible (cat_col, num_col) combination.

    Args:
        chains: List of operator chains from grammar search
        profile: Dataset profile

    Returns:
        List of ProgramSpecs with specific column bindings
    """
    # Build eligible columns from profile
    binary_cat_cols = get_eligible_binary_categorical_cols(profile)
    numeric_cols = get_eligible_numeric_cols(profile)

    programs = []

    for chain_idx, chain in enumerate(chains):
        # Determine which chains need categorical/numeric bindings
        needs_cat = any(_requires_binding(op.op_name, "cat_col") for op in chain)
        needs_num = any(_requires_binding(op.op_name, "selected_col") for op in chain)

        # Enumerate bindings
        if needs_cat and needs_num:
            for cat_col in binary_cat_cols:
                for num_col in numeric_cols:
                    programs.append(
                        _bind_chain(
                            chain, cat_col=cat_col, num_col=num_col, chain_idx=chain_idx
                        )
                    )
        elif needs_cat:
            for cat_col in binary_cat_cols:
                programs.append(
                    _bind_chain(chain, cat_col=cat_col, chain_idx=chain_idx)
                )
        elif needs_num:
            for num_col in numeric_cols:
                programs.append(
                    _bind_chain(chain, num_col=num_col, chain_idx=chain_idx)
                )
        else:
            programs.append(_bind_chain(chain, chain_idx=chain_idx))

    return programs


def _requires_binding(op_name: str, binding_key: str) -> bool:
    """Check if operator requires a specific binding key."""
    op = get_operator(op_name)
    if op is None:
        return False
    return op.requires_bindings.get(binding_key, False)


def _bind_chain(
    chain: List[OpInstance], cat_col=None, num_col=None, chain_idx=0
) -> ProgramSpec:
    """Create ProgramSpec with specific column bindings."""

    name = f"program_{chain_idx}"
    if cat_col:
        name += f"_{cat_col}"
    if num_col:
        name += f"_{num_col}"

    return ProgramSpec(
        name=name,
        ops=[_bind_instance(op, cat_col=cat_col, num_col=num_col) for op in chain],
        output_type="dict",
        output_schema="Generated by compositional generator",
        difficulty="EASY",
        tags=["generated"],
    )


def _bind_instance(instance: OpInstance, cat_col=None, num_col=None) -> OpInstance:
    """Bind column params to OpInstance (no arbitrary selection)."""
    params = instance.params.copy()

    op = get_operator(instance.op_name)
    if op is not None:
        if cat_col is not None and op.requires_bindings.get("cat_col", False):
            params["cat_col"] = cat_col
        if num_col is not None and op.requires_bindings.get("selected_col", False):
            params["selected_col"] = num_col

    return OpInstance(op_name=instance.op_name, params=params)


def get_operator(name: str):
    from src.datagen.synthetic.programs.operators import OPERATORS

    return OPERATORS.get(name)
